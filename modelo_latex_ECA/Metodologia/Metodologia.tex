\chapter{Materiais e Métodos}
\markright{\thechapter ~~~ Metodologia}
Neste capítulo são descritos os recursos de hardware e software necessários para o desenvolvimento deste projeto. São listados IDE utilizada para desenvolvimento, arquitetura existente a consumir dados da aplicação e escolha de algoritmos de cálculo de KPIs. Também são apresentados os processos de desenvolvimento de software utilizados e funcionamento da equipe dentro da qual foi o projeto foi construído.

\section{Descrição de Componentes}

Esta seção apresenta a arquitetura existente que receberá a aplicação desenvolvida, o Kpi-Executor, bem como os recursos de hardware e software utilizados no seu desenvolvimento.

\subsection{Software}

\subsubsection{IDE, Linguagem e Banco de Dados}

Para o desenvolvimento da aplicação foi escolhida a linguagem \textit{Python} \cite{pyPage}, em sua versão $3.8$, devido a seu caráter de alto nível e sua grande gama de bibliotecas disponíveis. Para a codificação foi escolhida a IDE \textit{Visual Studio Code} \cite{vscodePage}, devido à sua multiplicidade de extensões e também por já ser amplamente utilizada pela comunidade de desenvolvedores de software.

Ambas, linguagem e IDE, tem característica \textit{opensource}, sendo ativamente utilizadas e exploradas dia a dia por sua ampla comunidade, além de terem seus módulos e extensões gratuitos.

Quanto ao armazenamento dos dados, foi utilizada uma estrutura relacional de banco de dados, considerando sua praticidade, bem como a estrutura existente descrita nas próximas seções. Foi utilizada uma instância de um banco de dados \textit{PostgresSQL} \cite{postgresPage} , uma ferramenta gratuita para a persistência dos dados gerados pela aplicação.

\subsubsection{Orquestradores e Containers}

Como a aplicação desenvolvida foi acoplada a um sistema existente, foi necessário que ela respeitasse o conjunto anteriormente elaborado, bem como se adequasse à arquitetura em nuvem \cite{cloudComp} já em funcionamento. Para tal, essa aplicação deveria possuir certo encapsulamento.

Uma forma amplamente utilizada para o encapsulamento e execução de aplicações de grande porte é o formato de \textit{containers}. É uma abordagem de desenvolvimento de software onde um serviço ou aplicativo é empacotado com suas dependências e configurações \cite{containerIntr}. Dessa forma, são facilitados os processos de Testes de unidade e integração \cite{engSw}, bem como etapas de evolução \cite{engSw} e versionamento daquele conjunto. Para o processo de construção de \textit{container} do módulo \textit{Kpi-Executor} foi utilizada a plataforma \textit{Docker} \cite{dockerPage}, gerando uma imagem de um SO (Sistema Operacional) Linux contendo as dependências e instalações necessárias para a execução do \textit{Kpi-Executor}.

Uma vez empacotada a aplicação, é necessário utilizar uma ferramenta para operar esse pacote, o executando sempre que necessário. Esta utilidade é chamada de \textit{orquestrador}. A ferramenta deste tipo utilizada foi o \textit{Kubernetes} \cite{kubePage}. Este tipo de ferramenta possibilita a automação de operações \textit{containers}, como implantações ou atualizações das aplicações, o gerenciamento de serviços de forma declarativa garantindo a repetibilidade do sistema, a separação de \textit{containers} em diferentes \textit{hosts}, bem como a verificação de integridade e autorrecuperação das aplicações \cite{whatKube}.


\subsection{Estrutura Existente}
\label{sec:estruturaExistente}
A aplicação construída funcionará como um módulo de um sistema de CPM existente chamado LOOP. Ele é composto por um conjunto de módulos, cada um com sua responsabilidade bem definida. A figura \ref{fig:arqLoop} traz o esquema arquitetural do sistema, bem como o relacionamento entre os módulos.

\begin{figure}[!htbp]
	\centering		
	\includegraphics[width=10cm]{Metodologia/Figuras/arquitetura-omo.png}
	\caption{Arquitetura Loop}
	\label{fig:arqLoop}
\end{figure}

Neste esquema são identificadas as linguagens e tecnologias de cada módulo. São eles:

\begin{itemize}
	\item \textbf{Dashboard:} Aplicação web acessível ao usuário do sistema CPM LOOP composta por um \textit{backend} em \textit{Spring Boot} \cite{springBootPage} e \textit{frontend} em \textit{AngularJS} \cite{angularJSPage};
	\item \textbf{Bancos de Dados:} São três instâncias de banco de dados do sistema. A nomeada como \textit{omo-db} carrega as informações de cadastro e configuração das entidades do LOOP. A nomeada \textit{omokpi} armazena os dados calculados pelo Kpi-Executor, enquanto a \textit{logs} registra os logs de funcionamento da aplicação de cálculos. Todas as instâncias são do tipo PostgreSQL \cite{postgresPage};
	\item \textbf{Data-Service:} Módulo do tipo API construído em \textit{Spring Boot} \cite{springBootPage} responsável por prover dados registrados no banco \textit{omokpi} à aplicação web \textit{Dashboard}. Formata pesquisa e retorna dados sob demanda;
	\item \textbf{PIMS:} Um sistema PIMS da \textit{OsiSoft} chamado \textit{PI System} \cite{piPage}. Nele são armazenados os dados de processo dos clientes que utilizam o sistema LOOP. Estes dados são utilizados na realização dos cálculos (Kpi-Executor);
	\item \textbf{Pi-Facade:} Módulo do tipo API construído em \textit{Spring Boot} \cite{springBootPage} responsável por prover dados registrados e cadastrar novas informações no PIMS sob demanda da aplicação web \textit{Dashboard};
	\item \textbf{Pi-Connector:} Módulo do tipo API construído em \textit{NodeJS} \cite{nodejsPage} responsável pelo fornecimento de dados registrados no PIMS à aplicação de cálculos (Kpi-Executor);
	\item \textbf{Kpi-Executor:} Módulo desenvolvido descrito por esta monografia. Construído em \textit{Python 3.8} \cite{pyPage} e responsável por calcular os índices de performance (KPIs) do sistema LOOP. Opera de forma cíclica, realizando seus cálculos a cada hora.	
\end{itemize}


\newpage
\subsection{Hardware}
Para realização do desenvolvimento do Kpi-Executor, foi necessário um notebook com 16Gb de memória e processador intel i7. Também foi necessário um ambiente de Testes e validação semelhante ao de produção. São máquinas hospedadas na \textit{Amazon Web Services} \cite{awsHome}.



\section{Metodologia}
%\markright{\thesection ~~~ Metodologia}

Para a construção dessa aplicação foi utilizado o um processo de desenvolvimento de software composto por características de um cascata e um incremental \cite{engSw}. Como o projeto foi entendido como uma demanda associada ao fluxo de trabalho da equipe de Coder, descrita na seção \ref{sec:ihm}, ele estava submetido a um fluxo de \textit{Kanban}, o que aponta para o quesito de entrega incremental quando associado ao sistema LOOP como um todo. Entretanto, como se tratava de uma tarefa não pequena, foram necessárias etapas que coincidem com o processo cascata.
Neste capítulo serão listadas as etapas de projeto, desenvolvimento e testes do Kpi-Executor, bem como as escolhas relacionadas aos cálculos por ele realizados.

\subsection{Processo de Desenvolvimento}

O processo de desenvolvimento da aplicação iniciou-se com um escopo relativamente simples. Ela deveria realizar de forma cíclica um conjunto de cálculos de índices de performance que são utilizados pelo sistema CPM LOOP, registrá-los em um banco de dados existente, com estrutura também definida, e possibilitar um rastreio de falhas no fluxo de cálculos, identificando o qual tipo de erro, e em que momento este acontecera. Tendo essas informações, ainda foi eram necessárias mais definições de casos específicos não mapeados pela descrição inicial. 

\subsubsection{Levantamento do Requisitos}

\paragraph{Variáveis do Sistema}
\label{sec:varsistema}
%\todo[inline]{Explicar os conceitos de MV, PV e Modo utilizados no Kpi-Executor. Avaliar se deve entrar no levantamento de requisitos}
Conceitos importantes para a descrição e detalhamento do módulo construído são os seguintes:
\begin{itemize}
	\item \textbf{\textit{Setpoint} (SP):} Valor-alvo de um sistema de controle regulatório;
	\item \textbf{\textit{Process Value} (PV):} Variável de processo a ser controlada por uma malha de controle. O objetivo de uma malha é fazer com que a \textit{PV} atinja o valor escolhido como \textit{Setpoint};
	\item \textbf{\textbf{\textit{Manipulated Value}} (MV):} Em contextos de processo, MV é a variável que uma malha de controle utiliza para atuar no valor final da PV. Exemplos são aberturas de válvulas e velocidades de bomba;
	\item \textbf{Modo:} Malhas de controle costumam possuir modos de operação que habilitam ou não um tipo de controle específico. Exemplos de modo são automático, manual e cascata.
\end{itemize}

\paragraph{Fluxo desejado}
\label{sec:levantRequisitos}
Considerando a necessidade de um mapeamento detalhado dos casos de cálculo, foi realizado um processo de entrevista com o PO (\textit{Product Owner}) do sistema LOOP, a fim de elucidar o fluxo de cálculo em seu estado ideal, possíveis tratativas em casos não usuais e demais requisitos funcionais e não-funcionais. Deste levantamento, foi elaborado o diagrama de sequência (\ref{sec:modSeq}) tratando o fluxo a ser executado pelo Kpi-Executor, exibido na figura (\ref{fig:fluxoKpi}).

 \begin{figure}[!htbp]
 	\centering		
 	\includegraphics[width=14cm]{Metodologia/Figuras/fluxoKpiExecutor.png}
 	\caption{Diagrama de Sequência - Kpi-Executor}
 	\label{fig:fluxoKpi}
 \end{figure}
 
Após construção deste diagrama de alto nível, foi realizada o nova reunião o validando como fluxo correto de cálculos, incluindo as tratativas de casos específicos. Assim pôde-se caminhar para a próxima etapa do processo.

\subsubsection{Projeto da Aplicação}
\label{sec:projAplicacao}
Tendo requisitos funcionais e não-funcionais especificados, foi possível então o início do projeto da aplicação. Inicia-se pela definição arquitetural do módulo Kpi-Executor. Foi escolhida uma arquitetura em camadas (seção \ref{sec:arqCamadas}) devido à familiaridade da equipe com o tipo de construção e a seu caráter de atuação sob demanda e persistência em banco de dados. 

Para persistência dos dados em banco, foi escolhida a tecnologia SQLAlchemy \cite{alchemyPage}, amplamente utilizada para acesso via Python a bancos de dados relacionais. Ela possibilita uma abordagem de orientação a objetos (seção \ref{sec:seqOO}) em sua utilização.

\subsubsection{Desenvolvimento da Aplicação}

\paragraph {Classes auxiliares}
\label{sec:objDb}
Considerando a estrutura do sistema da empresa parceira (Loop) no momento do desenvolvimento do módulo tratado por essa monografia, era tido como de suma importância a possibilidade de utilização de diferentes bancos de dados relacionais, como Microfost SQL Server \cite{sqlServerHome} e PostgresSQL \cite{postgresPage}. Assim, foi necessária a utilização da uma \textit{ORM} (Object Relacional Mapper) \cite{ORM} \textit{SQLAlchemy} \cite{alchemyPage}, possibilitando que o módulo em questão apresentasse características agnósticas a banco de dados. Além da facilitação no processo de substituição de bancos de dados, devido à objetificação das \textit{queries} adiciona segurança ao conjunto do sistema, impedindo tentativas de invasão do tipo \textit{SQL Injection} \cite{SQLInjection}.

Uma vez levantados os pontos citados, foram utilizados os conceitos de orientação a objetos para o desenvolvimento (\ref{sec:seqOO}) para a elaboração de duas classes que juntas tornariam o processo de construção das consultas e inserções a banco de dados mais práticas e robustas:

\begin{itemize}
	\item \textbf{Database:} Classe que contempla métodos para conexão e desconexão com o banco de dados, bem como as informações de conexão, como \textit{host}, nome do banco, usuário, senha e \textit{driver}. Seu uso consiste na representação de um banco de dados como um objeto. O \textit{SQLAlchemy} \cite{alchemyPage} faz gerenciamento automático de múltiplas conexões, possibilitando o instanciamento de diversos objetos dessa classe;
	\item \textbf{Repository:} Classe que contempla os métodos básicos relacionados a consultas, inserções, atualizações e deleções. Seu uso consiste em tê-la como pai para cada nova classe com funções de acesso a dados. Possui um atributo do tipo \textit{Database} que aponta para o banco de dados a ser utilizado.
\end{itemize}

Uma vez elaboradas tais classes auxiliares, tem-se a etapa seguinte que contempla o conceito de divisão de camadas (\ref{sec:arqCamadas}), novamente orientação a objetos (\ref{sec:seqOO}) e modelagem orientada a dados (\ref{sec:modSeq}).



Conceitos importantes para retomar são os 

\paragraph{Índices de Performance - KPIs}
\label{sec:indicesPerformance}

Como relatado na seção \ref{sec:automation_kpis}, os índices de performance calculados pelo módulo construído, se baseiam em índices frequentemente utilizados para a medição de qualidade de malhas de controle regulatório. Tais cálculos são realizados periodicamente, utilizando os dados de processo que foram armazenados no PIMS na hora anterior à sua execução. Dessa forma, todos os cálculos aqui descritos são relacionados a um período de uma hora. Nessa seção são descritos cada um deles.

\begin{itemize}
	\item \textbf{Tempo em modo normal:} Para cada malha cadastrada no sistema LOOP (seção \ref{sec:estruturaExistente} ) é cadastrado um modo como estado normal. Este \textit{KPI} consiste na avaliação da porcentagem do tempo em que tal malha esteve neste estado.
	
	\begin{equation}
	T_{normal} [\%] = \frac{n_{modoNormal}}{n_{totalAmostras}} \times 100
	\end{equation}
	
	É utilizado pelo analista para inferências sobre possíveis problemas relacionados a uma má parametrização de um sistema de controle regulatório. Gera perguntas como "Porque esta malha não tem se mantido no modo de operação que deveria ser o normal?";
	\item \textbf{Tempo sem saturação:} Consiste na avaliação da porcentagem de tempo em que a MV se manteve dentro dos limites normais de operação previamente cadastrados
	
	\begin{equation}
	T_{semSaturacao} [\%] = \frac{n_{dentroLimite}}{n_{totalAmostras}} \times 100
	\end{equation}
	
	Tem índice também diz sobre um sistema de controle mal parametrizado. Uma malha que possui um tempo sem saturação baixo pode apresentar defeitos em seus atuadores com uma frequência alta.
	\item \textbf{Erro médio aceitável:} O cálculo deste \textit{KPI} passa por algumas etapas:
	\subitem \textit{Cálculo de erro:} O erro é dado pela diferença absoluta entre o SP e a PV. Tal cálculo é realizado para cada amostra dos vetores de dados.
	
	\begin{equation}
	erro = |SP - PV|
	\end{equation}
	
	Assim é gerado um vetor com os erros de cada amostra.
	\subitem \textit{Boxplot:} Também conhecido como \textit{gráfico de caixa} é utilizado para a avaliação da distribuição empírica dos dados \cite{capela_boxplot}. Nele são utilizados primeiro ($Q_1$), segundo ($Q_2$) e terceiro ($Q_3$) quartis para sua construção. Esta etapa é realizada com o vetor de dados gerado o item anterior.
	
	\begin{figure}[!htbp]
		\centering		
		\includegraphics[width=14cm]{Metodologia/Figuras/boxplot.png}
		\caption{Formação de Boxplot}
		\label{fig:boxlot}
	\end{figure}
	
	Para o cálculo de cada um dos quartis é utilizado o conceito de \textit{percentil}. Ele divide o conjunto de dados em 100 partes iguais e indica a porcentagem de dados que estão abaixo daquela parte. Para a avaliação do percentil é necessário que os dados estejam ordenados de forma crescente. As relações matemáticas que o definem são dadas pelas equações \ref{eq:posicaoPercentil} e \ref{eq:percentil}.
	
	\begin{equation}
	\label{eq:posicaoPercentil}
	L = \frac{k}{100}\times n
	\end{equation}
	
	Sendo $L$ a posição do percentil desejado no conjunto de dados, $k$ o percentil desejado e $n$ o tamanho do vetor de dados analisado. 
	
	\begin{equation}
	\label{eq:percentil}
	P_k = \begin{cases}
	\frac{v_L + v_{L+1}}{100}  & \text{caso \textit{L} seja inteiro}\\
	v_{round(L)} & \text{caso \textit{L} não seja inteiro}
	
	\end{cases} 
	\end{equation}
	

	Sendo $v$ o vetor de dados a ser analisado, $L$ o valor obtido na equação \ref{eq:posicaoPercentil} e $P_k$ o \textit{k}-ésimo percentil a ser obtido. Existe um ligação direta entre percentis e os quartis utilizados para o \textit{Boxplot}. As equações \ref{eq:q1} a \ref{eq:q3} trazem tais relações.
	
	
	Sendo $n$ o número de amostras, $i$ o percentil desejado
	\begin{equation}
	\label{eq:q1}
	Q_1 = P_{25}
	\end{equation}
	
	\begin{equation}
	\label{eq:q2}
	Q_2 = P_{50}
	\end{equation}
	
	\begin{equation}
	\label{eq:q3}
	Q_3 = P_{75}
	\end{equation}
	
	\subsubitem \textit{Normalização:} Uma vez obtidos os quartis $Q_1$ a $Q_3$, é obtido o valor de $iqr$, dado pela diferença entre $Q_3$ e $Q_1$.
	
	\begin{equation}
	iqr = Q_3 - Q_1
	\end{equation}
	
	Em seguida são inseridos os conceitos de \textit{meta} e \textit{limiar}. Ambos se apoiam nos quatis calculados até este ponto. Podem ser vistos como os limites inferior e superior, respectivamente, destacados na figura \ref{fig:boxlot}.
	
	\begin{equation}
	meta = Q_1 - Gap \times iqr
	\end{equation}
	
	\begin{equation}
	limiar = Q_3 + Gap \times iqr
	\end{equation}
	
	Tendo $Gap = 0,1$ como padrão para o sistema. Em seguida é definido o \textit{divisor}, dado pela diferença entre \textit{limiar} e \textit{meta}.
	
	\begin{equation}
	divisor = limiar - meta
	\end{equation}
	
	Também é realizado o cálculo do chamado \textit{Erro Médio Absoluto}, identificado como $EMA$. Consiste, como o nome explicita, na média dos valores absolutos de erro nos dados analisados.
	
	\begin{equation}
	EMA = \frac{\sum_{1}^{n_{amostras}} erro_i}{n_{amostras}}
	\end{equation}
	
	Finalmente, após as etapas descritas é possível obter o \textit{KPI} de \textit{Erro Médio Aceitável}, identificado como $EMA_{norm}$.
	
	\begin{equation}
	EMA_{norm} [\%] = \frac{EMA - meta}{divisor} 
	\end{equation}
	
	\item \textbf{Nota Global:} É dada pela média dos \textit{KPIs} calculados naquele ciclo. Caso o cálculo de um índice seja aplicável ao ciclo avaliado, ele entra para o cálculo deste.
	
	\begin{equation}
	NotaGlobal = \frac{\sum_{i}^{n} KPI_i}{n_{KPI}}
	\end{equation}
\end{itemize}

\paragraph{Divisão de Responsabilidades}

Considerando uma arquitetura de camadas, o Kpi-Executor foi modularizado dividindo as responsabilidades entre estes módulos. Foram separadas entre os componentes as tarefas de se consumir e escrever em diferentes bases de dados, operar o fluxo de cálculos, registrar exceções e falhas de cálculo, etc. A figura \ref{fig:componentsKpi} traz o diagrama de componentes que descreve tal modularização.

\begin{figure}[!htbp]
	\centering		
	\includegraphics[width=14cm]{Metodologia/Figuras/kpiComponents.png}
	\caption{Diagrama de Componentes - Kpi-Executor}
	\label{fig:componentsKpi}
\end{figure}

Cada componente descrito no diagrama é composto por um arquivo independente em Python \cite{pyPage}, cada um com suas responsabilidades. 

\begin{itemize}
	\item \textbf{app:} Arquivo principal. Ele é o módulo invocado pelo orquestrador Kubernetes \cite{kubePage}. Responsável pela configuração de logs de manutenção e carregamento de variáveis de ambiente do sistema, configurando a aplicação para sua forma de execução local, em ambiente de validação ou produção;
	\item \textbf{execute:} Responsável por instanciar os objetos de banco de dados utilizados pelos próximos componentes. Também invoca DashboardService para montar o objeto com os dados de cadastro para as etapas de cálculos de KPIs;
	\item \textbf{makeCalc:} Opera o fluxo principal ta aplicação. Percorre o objeto de dados de cadastro fornecido pelo componente \textit{execute} e solicitando, a cada iteração, ao \textit{PiServerService} dados de processo cadastrados no PIMS, malha a malha;
	\item \textbf{DashboardService:} Possui regras de negócio relacionadas ao banco \textit{omo-db}. Formata os dados lidos e para inserção neste banco. Também possui os métodos para instanciar os objetos de banco de dados e para solicitar escrita no banco de dados;
	\item \textbf{DashboardRepository:} Possui os métodos correspondentes às queries de inserção e consulta de dados em banco. Tem relação de herança \cite{engSw} com a classe \textit{Repository} (seção \ref{sec:objDb});
	\item \textbf{PiServerService:} Contempla regras de negócio relacionadas à consulta de dados no PIMS. Formata e realiza requisições \textit{Http} para o módulo externo \textit{Pi-Connector} (figura \ref{fig:arqLoop}). Também possui rotinas para tratamento das respostas com os dados do PIMS;
	\item \textbf{KpiService:} Contempla as regras para formatação de dados calculados para inserção no banco \textit{omokpi};
	\item \textbf{LogsService:} Possui métodos para conexão com o banco de dados de logs de controle;
	\item \textbf{LogsRepository:} Possui métodos relacionados a inserção e leitura em dos logs em banco de dados. Tem relação de herança com a classe \textit{Repository} (seção \ref{sec:objDb});
	\item \textbf{CalculateController:} Componente chave para o funcionamento da aplicação. Contempla o fluxo descrito pelo levantamento de requisitos na figura \ref{fig:fluxoKpi}. Também invoca os módulos \textit{KpiService} e \textit{DashboardService} para registro de dados calculados e \textit{LogsService} para persistência dos logs de controle;
	\item \textbf{CalculateService:} Possui os métodos para a realização dos cálculos dos índices de performance. É invocado pelo \textit{calculateController};
	\item \textbf{CalculateValidation:} Possui métodos auxiliares para a validação do fluxo de cálculos. É invocado pelo \textit{CalulateController};
	
\end{itemize}


\paragraph{Registro de Falhas de Cálculo}

O fluxo de cálculo do módulo apresentado na seção \ref{sec:levantRequisitos} contempla o registro das falhas no processo de cálculo. Um dos requisitos levantados foi a necessidade do armazenamento desses casos, de forma organizada e escalável, viabilizando o consumo futuro dessas informações.

Uma boa prática para tratamento e organização de falhas, erros e casos inesperados é o tratamento de exceções. Ele é o mecanismo responsável pelo tratamento de condições que não respeitam o fluxo normal de funcionamento de um programa de computador. Considerando esses conceitos, foram criados diferentes tipos de exceção para diferenciar as falhas em cada etapa descrita pelo diagrama \ref{fig:fluxoKpi}:

\begin{itemize}
	\item \textbf{Exceções do Fluxo}: São lançadas em caso de problemas relacionados a ausência de dados necessários para os cálculos. Identificam qual dado está ausente, e correspondem às avaliações de condicionais do fluxo. No diagrama de sequência (\ref{fig:fluxoKpi}) são representadas pelos losangos.
	\subitem \textit{NoLoopDataException:} Exceção lançada caso os dados do PIMS não estejam disponíveis por algum motivo;
	\subitem \textit{OfflineLoopException:} Lançada caso a malha analisada naquela iteração esteja em estado \textit{offline}, ou seja, sem o monitoramento do sistema;
	\subitem \textit{MVException:} Semelhante à primeira, porém relativa somente aos dados de MV (seção \ref{sec:varsistema}). Caso não haja dados, a exceção é lançada;
	\subitem \textit{ModoException:} Relativa à ausência de dados de Modo (seção \ref{sec:varsistema}). Caso não existam dados, é lançada uma exceção desse tipo;
	\subitem \textit{PVSPException:} Relativa à ausência de dados de PV e/ou SP (seção \ref{sec:varsistema}). Caso não existam dados, é lançada uma exceção desse tipo;
	\item \textbf{Exceções nos cálculos:} São lançadas caso ocorra alguma falha durante as operações de cálculos. No diagrama de sequência (\ref{fig:fluxoKpi}) são representadas pelos retângulos.
	\subitem \textit{NoSatCalculateException:} Falha no processo de cálculo do KPI \textit{Tempo sem saturação}. É lançada uma exceção desse tipo com as informações da falha capturada;
	\subitem \textit{TimeNormalCalculateException:} Falha no processo de cálculo do KPI \textit{Tempo em modo normal}.
	\subitem \textit{EMACalculateException:} Falha no processo de cálculo do KPI \textit{Erro Médio Aceitável};
	\subitem \textit{GlobalPerformanceCalculateException:} Falha do processo de cálculo do KPI \textit{Performance Global}.
\end{itemize}

Uma vez criados os tipos de exceções, para a possibilidade de consumo futuro destes dados, bem como para análise de possíveis gargalos no sistema, tais falhas foram registradas em uma tabela no banco de dados relacional PostgresSQL \cite{postgresPage}, conforme indicado na figura \ref{fig:arqLoop}. A tabela responsável por esse armazenamento possui as seguintes informações:

\begin{itemize}
	\item \textbf{message:} Mensagem que pode ser personalizada em cada caso;
	\item \textbf{file\_name:} Arquivo do projeto que apresentou a exceção em questão;
	\item \textbf{line\_number:} Linha do arquivo que apresentou a exceção;
	\item \textbf{exception:} Classe da exceção ocorrida;
	\item \textbf{documentation:} Informação nativa da exceção, caso não seja de uma das classes criadas;
	\item \textbf{web\_id:} Identificador único da malha que operava o cálculo de KPI;
	\item \textbf{timestamp:} \textit{Timestamp} com informação de quando ocorreu o problema;
\end{itemize}

\subsubsection{Testes e Implantação}
\todo[inline]{Explicar etapas de teste com dados de cliente e validação de fluxo e resultados de cálculos dos índices de performance}
\clearpage