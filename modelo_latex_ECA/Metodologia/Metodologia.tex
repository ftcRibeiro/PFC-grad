\chapter{Materiais e Métodos}
\markright{\thechapter ~~~ Metodologia}
Neste capítulo são descritos os recursos de hardware e software necessários para o desenvolvimento deste projeto. São listados IDE utilizada para desenvolvimento, arquitetura existente a consumir dados da aplicação e escolha de algoritmos de cálculo de KPIs. Também são apresentados os processos de desenvolvimento de software utilizados e funcionamento da equipe dentro da qual foi o projeto foi construído.

\section{Descrição de Componentes}

Esta seção apresenta a arquitetura existente que receberá a aplicação desenvolvida, o Kpi-Executor, bem como os recursos de hardware e software utilizados no seu desenvolvimento.

\subsection{Software}

\subsubsection{IDE, Linguagem e Banco de Dados}

Para o desenvolvimento da aplicação foi escolhida a linguagem \textit{Python} \cite{pyPage}, em sua versão $3.8$, devido a seu caráter de alto nível e sua grande gama de bibliotecas disponíveis. Para a codificação foi escolhida a IDE \textit{Visual Studio Code} \cite{vscodePage}, devido à sua multiplicidade de extensões e também por já ser amplamente utilizada pela comunidade de desenvolvedores de software.

Ambas, linguagem e IDE, tem característica \textit{opensource}, sendo ativamente utilizadas e exploradas dia a dia por sua ampla comunidade, além de terem seus módulos e extensões gratuitos.

Quanto ao armazenamento dos dados, foi utilizada uma estrutura relacional de banco de dados, considerando sua praticidade, bem como a estrutura existente descrita nas próximas seções. Foi utilizada uma instância de um banco de dados \textit{PostgresSQL} \cite{postgresPage} , uma ferramenta gratuita para a persistência dos dados gerados pela aplicação.

\subsubsection{Orquestradores e Containers}

Como a aplicação desenvolvida foi acoplada a um sistema existente, foi necessário que ela respeitasse o conjunto anteriormente elaborado, bem como se adequasse à arquitetura em nuvem \cite{cloudComp} já em funcionamento. Para tal, essa aplicação deveria possuir certo encapsulamento.

Uma forma amplamente utilizada para o encapsulamento e execução de aplicações de grande porte é o formato de \textit{containers}. É uma abordagem de desenvolvimento de software onde um serviço ou aplicativo é empacotado com suas dependências e configurações \cite{containerIntr}. Dessa forma, são facilitados os processos de Testes de unidade e integração \cite{engSw}, bem como etapas de evolução \cite{engSw} e versionamento daquele conjunto. Para o processo de construção de \textit{container} do módulo \textit{Kpi-Executor} foi utilizada a plataforma \textit{Docker} \cite{dockerPage}, gerando uma imagem de um SO (Sistema Operacional) Linux contendo as dependências e instalações necessárias para a execução do \textit{Kpi-Executor}.

Uma vez empacotada a aplicação, é necessário utilizar uma ferramenta para operar esse pacote, o executando sempre que necessário. Esta utilidade é chamada de \textit{orquestrador}. A ferramenta deste tipo utilizada foi o \textit{Kubernetes} \cite{kubePage}. Este tipo de ferramenta possibilita a automação de operações \textit{containers}, como implantações ou atualizações das aplicações, o gerenciamento de serviços de forma declarativa garantindo a repetibilidade do sistema, a separação de \textit{containers} em diferentes \textit{hosts}, bem como a verificação de integridade e autorrecuperação das aplicações \cite{whatKube}.


\subsection{Estrutura Existente}

A aplicação construída funcionará como um módulo de um sistema de CPM existente chamado LOOP. Ele é composto por um conjunto de módulos, cada um com sua responsabilidade bem definida. A figura \ref{fig:arqLoop} traz o esquema arquitetural do sistema, bem como o relacionamento entre os módulos.

\begin{figure}[!htbp]
	\centering		
	\includegraphics[width=10cm]{Metodologia/Figuras/arquitetura-omo.png}
	\caption{Arquitetura Loop}
	\label{fig:arqLoop}
\end{figure}

Neste esquema são identificadas as linguagens e tecnologias de cada módulo. São eles:

\begin{itemize}
	\item \textbf{Dashboard:} Aplicação web acessível ao usuário do sistema CPM LOOP composta por um \textit{backend} em \textit{Spring Boot} \cite{springBootPage} e \textit{frontend} em \textit{AngularJS} \cite{angularJSPage};
	\item \textbf{Bancos de Dados:} São três instâncias de banco de dados do sistema. A nomeada como \textit{omo-db} carrega as informações de cadastro e configuração das entidades do LOOP. A nomeada \textit{omokpi} armazena os dados calculados pelo Kpi-Executor, enquanto a \textit{logs} registra os logs de funcionamento da aplicação de cálculos. Todas as instâncias são do tipo PostgreSQL \cite{postgresPage};
	\item \textbf{Data-Service:} Módulo do tipo API construído em \textit{Spring Boot} \cite{springBootPage} responsável por prover dados registrados no banco \textit{omokpi} à aplicação web \textit{Dashboard}. Formata pesquisa e retorna dados sob demanda;
	\item \textbf{PIMS:} Um sistema PIMS da \textit{OsiSoft} chamado \textit{PI System} \cite{piPage}. Nele são armazenados os dados de processo dos clientes que utilizam o sistema LOOP. Estes dados são utilizados na realização dos cálculos (Kpi-Executor);
	\item \textbf{Pi-Facade:} Módulo do tipo API construído em \textit{Spring Boot} \cite{springBootPage} responsável por prover dados registrados e cadastrar novas informações no PIMS sob demanda da aplicação web \textit{Dashboard};
	\item \textbf{Pi-Connector:} Módulo do tipo API construído em \textit{NodeJS} \cite{nodejsPage} responsável pelo fornecimento de dados registrados no PIMS à aplicação de cálculos (Kpi-Executor);
	\item \textbf{Kpi-Executor:} Módulo desenvolvido descrito por esta monografia. Construído em \textit{Python 3.8} \cite{pyPage} e responsável por calcular os índices de performance (KPIs) do sistema LOOP. Opera de forma cíclica, realizando seus cálculos a cada hora.
	
\end{itemize}


\newpage
\subsection{Hardware}
Para realização do desenvolvimento do Kpi-Executor, foi necessário um notebook com 16Gb de memória e processador intel i7. Também foi necessário um ambiente de Testes e validação semelhante ao de produção. São máquinas hospedadas na \textit{Amazon Web Services} \cite{awsHome}.



\section{Metodologia}
%\markright{\thesection ~~~ Metodologia}

Para a construção dessa aplicação foi utilizado o um processo de desenvolvimento de software composto por características de um cascata e um incremental \cite{engSw}. Como o projeto foi entendido como uma demanda associada ao fluxo de trabalho da equipe de Coder, descrita na seção \ref{sec:ihm}, ele estava submetido a um fluxo de \textit{Kanban}, o que aponta para o quesito de entrega incremental quando associado ao sistema LOOP como um todo. Entretanto, como se tratava de uma tarefa não pequena, foram necessárias etapas que coincidem com o processo cascata.
Neste capítulo serão listadas as etapas de projeto, desenvolvimento e testes do Kpi-Executor, bem como as escolhas relacionadas aos cálculos por ele realizados.

\subsection{Processo de Desenvolvimento}

O processo de desenvolvimento da aplicação iniciou-se com um escopo relativamente simples. Ela deveria realizar de forma cíclica um conjunto de cálculos de índices de performance que são utilizados pelo sistema CPM LOOP, registrá-los em um banco de dados existente, com estrutura também definida, e possibilitar um rastreio de falhas no fluxo de cálculos, identificando o qual tipo de erro, e em que momento este acontecera. Tendo essas informações, ainda foi eram necessárias mais definições de casos específicos não mapeados pela descrição inicial. 

\subsubsection{Levantamento do Requisitos}

Considerando a necessidade de um mapeamento detalhado dos casos de cálculo, foi realizado um processo de entrevista com o PO (\textit{Product Owner}) do sistema LOOP, a fim de elucidar o fluxo de cálculo em seu estado ideal, possíveis tratativas em casos não usuais e demais requisitos funcionais e não-funcionais. Deste levantamento, foi elaborado o diagrama de sequência (\ref{sec:modSeq}) tratando o fluxo a ser executado pelo Kpi-Executor, exibido na figura (\ref{fig:fluxoKpi}).

 \begin{figure}[!htbp]
 	\centering		
 	\includegraphics[width=14cm]{Metodologia/Figuras/fluxoKpiExecutor.png}
 	\caption{Diagrama de Sequência - Kpi-Executor}
 	\label{fig:fluxoKpi}
 \end{figure}
 
Após construção deste diagrama de alto nível, foi realizada o nova reunião o validando como fluxo correto de cálculos, incluindo as tratativas de casos específicos. Assim pôde-se caminhar para a próxima etapa do processo.

\subsubsection{Projeto da Aplicação}

Tendo requisitos funcionais e não-funcionais especificados, foi possível então o início do projeto da aplicação. Inicia-se pela definição arquitetural do módulo Kpi-Executor. Foi escolhida uma arquitetura em camadas (seção \ref{sec:arqCamadas}) devido à familiaridade da equipe com o tipo de construção e a seu caráter de atuação sob demanda e persistência em banco de dados. 

Para persistência dos dados em banco, foi escolhida a tecnologia SQLAlchemy \cite{alchemyPage}, amplamente utilizada para acesso via Python a bancos de dados relacionais. Ela possibilita uma abordagem de orientação a objetos (seção \ref{sec:seqOO}) em sua utilização.

\subsubsection{Desenvolvimento da Aplicação}

%\paragraph {Objeto de Banco de Dados}
%\label{sec:objDb}
%\todo[inline]{Aqui adicionarei a descrição da construção do objeto de banco de Dados criado como um ferramental escalável e substituível do sistema.}

\paragraph{Divisão de Responsabilidades}

Considerando uma arquitetura de camadas, o Kpi-Executor foi modularizado dividindo as responsabilidades entre estes módulos. Foram separadas entre os componentes as tarefas de se consumir e escrever em diferentes bases de dados, operar o fluxo de cálculos, registrar exceções e falhas de cálculo, etc. A figura \ref{fig:componentsKpi} traz o diagrama de componentes que descreve tal modularização.

\begin{figure}[!htbp]
	\centering		
	\includegraphics[width=14cm]{Metodologia/Figuras/kpiComponents.png}
	\caption{Diagrama de Componentes - Kpi-Executor}
	\label{fig:componentsKpi}
\end{figure}

Cada componente descrito no diagrama é composto por um arquivo independente em Python \cite{pyPage}, cada um com suas responsabilidades. 

\begin{itemize}
	\item \textbf{app:} Arquivo principal. Ele é o módulo invocado pelo orquestrador Kubernetes \cite{kubePage}. Responsável pela configuração de logs de manutenção e carregamento de variáveis de ambiente do sistema, configurando a aplicação para sua forma de execução local, em ambiente de validação ou produção;
	\item \textbf{execute:} Responsável por instanciar os objetos de banco de dados utilizados pelos próximos componentes. Também invoca DashboardService para montar o objeto com os dados de cadastro para as etapas de cálculos de KPIs;
	\item \textbf{makeCalc:} Opera o fluxo principal ta aplicação. Percorre o objeto de dados de cadastro fornecido pelo componente \textit{execute} e solicitando, a cada iteração, ao \textit{PiServerService} dados de processo cadastrados no PIMS, malha a malha;
	\item \textbf{DashboardService:} Possui regras de negócio relacionadas ao banco \textit{omo-db}. Formata os dados lidos e para inserção neste banco. Também possui os métodos para instanciar os objetos de banco de dados e para solicitar escrita no banco de dados;
	\item \textbf{DashboardRepository:} Possui os métodos correspondentes às queries de inserção e consulta de dados em banco. Tem relação de herança \cite{engSw} com a classe \textit{Repository} (seção \ref{sec:objDb});
	\item \textbf{PiServerService:} Contempla regras de negócio relacionadas à consulta de dados no PIMS. Formata e realiza requisições \textit{Http} para o módulo externo \textit{Pi-Connector} (figura \ref{fig:arqLoop}). Também possui rotinas para tratamento das respostas com os dados do PIMS;
	\item \textbf{KpiService:} Contempla as regras para formatação de dados calculados para inserção no banco \textit{omokpi};
	\item \textbf{LogsService:} Possui métodos para conexão com o banco de dados de logs de controle;
	\item \textbf{LogsRepository:} Possui métodos relacionados a inserção e leitura em dos logs em banco de dados. Tem relação de herança com a classe \textit{Repository} (seção \ref{sec:objDb});
	\item \textbf{CalculateController:} Componente chave para o funcionamento da aplicação. Contempla o fluxo descrito pelo levantamento de requisitos na figura \ref{fig:fluxoKpi}. Também invoca os módulos \textit{KpiService} e \textit{DashboardService} para registro de dados calculados e \textit{LogsService} para persistência dos logs de controle;
	\item \textbf{CalculateService:} Possui os métodos para a realização dos cálculos dos índices de performance. É invocado pelo \textit{calculateController};
	\item \textbf{CalculateValidation:} Possui métodos auxiliares para a validação do fluxo de cálculos. É invocado pelo \textit{CalulateController};
	
\end{itemize}

% \paragraph{Índices de Performance - KPIs}
%
%\todo[inline]{Explicar os cálculos realizados e citar a seção (ainda não construída) da revisão bibliográfica sobre os índices de performance.}
%
%\paragraph{Registro de Logs de Cálculo}
%
%\todo[inline]{Adicionar aqui o processo de estruturação dos logs de cálculo em banco de dados. Associar esse processo ao fluxo da seção de levantamento de requisitos.}
%
%
%\subsubsection{Testes e Implantação}
%\todo[inline]{Explicar etapas de teste com dados de cliente e validação de fluxo e resultados de cálculos dos índices de performance}
\clearpage